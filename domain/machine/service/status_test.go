// Copyright 2025 Canonical Ltd.
// Licensed under the AGPLv3, see LICENCE file for details.

package service

import (
	stdtesting "testing"

	"github.com/juju/tc"

	"github.com/juju/juju/core/status"
	"github.com/juju/juju/domain/machine"
	"github.com/juju/juju/internal/testhelpers"
)

type statusSuite struct {
	testhelpers.IsolationSuite
}

func TestStatusSuite(t *stdtesting.T) { tc.Run(t, &statusSuite{}) }
func (s *statusSuite) TestEncodeMachineStatus(c *tc.C) {
	testCases := []struct {
		input  status.StatusInfo
		output machine.StatusInfo[machine.MachineStatusType]
	}{
		{
			input: status.StatusInfo{
				Status: status.Started,
			},
			output: machine.StatusInfo[machine.MachineStatusType]{
				Status: machine.MachineStatusStarted,
			},
		},
		{
			input: status.StatusInfo{
				Status: status.Stopped,
			},
			output: machine.StatusInfo[machine.MachineStatusType]{
				Status: machine.MachineStatusStopped,
			},
		},
		{
			input: status.StatusInfo{
				Status: status.Error,
			},
			output: machine.StatusInfo[machine.MachineStatusType]{
				Status: machine.MachineStatusError,
			},
		},
		{
			input: status.StatusInfo{
				Status: status.Pending,
			},
			output: machine.StatusInfo[machine.MachineStatusType]{
				Status: machine.MachineStatusPending,
			},
		},
		{
			input: status.StatusInfo{
				Status: status.Down,
			},
			output: machine.StatusInfo[machine.MachineStatusType]{
				Status: machine.MachineStatusDown,
			},
		},
		{
			input: status.StatusInfo{
				Status: status.Down,
				Data: map[string]interface{}{
					"foo": "bar",
				},
			},
			output: machine.StatusInfo[machine.MachineStatusType]{
				Status: machine.MachineStatusDown,
				Data:   []byte(`{"foo":"bar"}`),
			},
		},
	}

	for i, test := range testCases {
		c.Logf("test %d", i)
		output, err := encodeMachineStatus(test.input)
		c.Assert(err, tc.ErrorIsNil)
		c.Assert(output, tc.DeepEquals, test.output)
		result, err := decodeMachineStatus(output)
		c.Assert(err, tc.ErrorIsNil)
		c.Assert(result, tc.DeepEquals, test.input)
	}
}

func (s *statusSuite) TestEncodeInstanceStatus(c *tc.C) {
	testCases := []struct {
		input  status.StatusInfo
		output machine.StatusInfo[machine.InstanceStatusType]
	}{
		{
			input: status.StatusInfo{
				Status: status.Unset,
			},
			output: machine.StatusInfo[machine.InstanceStatusType]{
				Status: machine.InstanceStatusUnset,
			},
		},
		{
			input: status.StatusInfo{
				Status: status.Running,
			},
			output: machine.StatusInfo[machine.InstanceStatusType]{
				Status: machine.InstanceStatusRunning,
			},
		},
		{
			input: status.StatusInfo{
				Status: status.Provisioning,
			},
			output: machine.StatusInfo[machine.InstanceStatusType]{
				Status: machine.InstanceStatusAllocating,
			},
		},
		{
			input: status.StatusInfo{
				Status: status.ProvisioningError,
			},
			output: machine.StatusInfo[machine.InstanceStatusType]{
				Status: machine.InstanceStatusProvisioningError,
			},
		},
		{
			input: status.StatusInfo{
				Status: status.Running,
				Data: map[string]interface{}{
					"foo": "bar",
				},
			},
			output: machine.StatusInfo[machine.InstanceStatusType]{
				Status: machine.InstanceStatusRunning,
				Data:   []byte(`{"foo":"bar"}`),
			},
		},
	}

	for i, test := range testCases {
		c.Logf("test %d", i)
		output, err := encodeInstanceStatus(test.input)
		c.Assert(err, tc.ErrorIsNil)
		result, err := decodeInstanceStatus(output)
		c.Assert(err, tc.ErrorIsNil)
		c.Assert(result, tc.DeepEquals, test.input)
	}
}
